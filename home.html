<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Engine OCR Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .controls-section {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .control-group h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .file-upload {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-upload input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-upload-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 15px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.3s ease;
        }

        .file-upload-btn:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }

        .engine-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .engine-option {
            display: flex;
            align-items: center;
            padding: 10px;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .engine-option:hover {
            border-color: #007bff;
            background: #f8f9ff;
        }

        .engine-option.selected {
            border-color: #007bff;
            background: #e7f3ff;
        }

        .engine-option input[type=radio] {
            margin-right: 10px;
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            text-align: center;
        }

        .btn-primary {
            background: #28a745;
            color: white;
        }

        .btn-primary:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
            transform: translateY(-2px);
        }

        .btn-compare {
            background: #fd7e14;
            color: white;
        }

        .btn-compare:hover {
            background: #e56b0c;
            transform: translateY(-2px);
        }

        .image-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .image-container {
            position: relative;
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 15px;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            /* Prevent layout shifts */
            contain: layout;
        }

        .image-container.has-image {
            border-style: solid;
            border-color: #007bff;
        }

        .preview-image {
            max-width: 100%;
            max-height: 100%;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            display: block;
            object-fit: contain;
            /* Prevent dragging */
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
            /* Prevent selection */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Prevent touch actions on mobile */
            touch-action: none;
        }

        .bbox-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .bbox-drawing {
            position: absolute;
            border: 2px solid #ff6b35;
            background: rgba(255, 107, 53, 0.1);
            pointer-events: none;
            border-radius: 5px;
            z-index: 15;
        }

        .bbox-detected {
            position: absolute;
            border: 2px solid #28a745;
            background: rgba(40, 167, 69, 0.1);
            pointer-events: all;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
            z-index: 20;
        }

        .bbox-detected:hover {
            background: rgba(40, 167, 69, 0.2);
            transform: scale(1.02);
        }

        .bbox-label {
            position: absolute;
            top: -25px;
            left: 0;
            background: #28a745;
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 0.8em;
            white-space: nowrap;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .results-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
        }

        .results-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 20px;
        }

        .results-header h3 {
            color: #495057;
            font-size: 1.5em;
        }

        .clear-results {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .results-grid {
            display: grid;
            gap: 20px;
        }

        .result-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .result-engine {
            background: #007bff;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .result-confidence {
            background: #28a745;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .result-text {
            font-size: 1.1em;
            color: #495057;
            line-height: 1.6;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .comparison-section {
            margin-top: 30px;
            background: #fff8e1;
            border: 2px solid #ffb74d;
            border-radius: 15px;
            padding: 25px;
        }

        .comparison-header {
            color: #e65100;
            font-size: 1.4em;
            margin-bottom: 20px;
            text-align: center;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .comparison-item {
            background: white;
            border: 1px solid #ffb74d;
            border-radius: 12px;
            padding: 20px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-ready {
            background: #28a745;
        }

        .status-error {
            background: #dc3545;
        }

        .status-processing {
            background: #ffc107;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .controls-section {
                grid-template-columns: 1fr;
            }
            
            .image-section {
                grid-template-columns: 1fr;
            }
            
            .comparison-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Multi-Engine OCR Interface</h1>
            <p>Advanced OCR processing with PaddleOCR and VietOCR engines</p>
        </div>

        <div class="main-content">
            <!-- Controls Section -->
            <div class="controls-section">
                <!-- File Upload -->
                <div class="control-group">
                    <h3>üìÅ Upload Image</h3>
                    <div class="file-upload">
                        <input type="file" id="imageInput" accept="image/*">
                        <button class="file-upload-btn" onclick="document.getElementById('imageInput').click()">
                            üì∑ Choose Image
                        </button>
                    </div>
                    <div id="fileInfo" style="margin-top: 10px; font-size: 0.9em; color: #6c757d;"></div>
                </div>

                <!-- Engine Selection -->
                <div class="control-group">
                    <h3>‚öôÔ∏è OCR Engine</h3>
                    <div class="engine-selector">
                        <div class="engine-option selected" data-engine="paddleocr">
                            <input type="radio" name="engine" value="paddleocr" checked>
                            <span>üî• PaddleOCR</span>
                            <span class="status-indicator status-ready"></span>
                        </div>
                        <div class="engine-option" data-engine="vietocr">
                            <input type="radio" name="engine" value="vietocr">
                            <span>üáªüá≥ VietOCR</span>
                            <span class="status-indicator status-ready"></span>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="control-group">
                    <h3>üéØ Actions</h3>
                    <div class="action-buttons">
                        <button class="btn btn-primary" id="detectAllBtn">
                            üîç Detect All Text
                        </button>
                        <button class="btn btn-secondary" id="clearAllBtn">
                            üóëÔ∏è Clear Results
                        </button>
                        <button class="btn btn-compare" id="compareBtn">
                            ‚öñÔ∏è Compare Engines
                        </button>
                    </div>
                </div>
            </div>

            <!-- Image Section -->
            <div class="image-section">
                <div class="image-container" id="imageContainer">
                    <div id="placeholderText" style="text-align: center; color: #6c757d;">
                        <h3>üì∑ Upload an image to start</h3>
                        <p>Supported formats: JPG, PNG, WEBP</p>
                    </div>
                    <img id="previewImage" class="preview-image" style="display: none;">
                    <div id="bboxOverlay" class="bbox-overlay"></div>
                </div>

                <div class="results-section">
                    <div class="results-header">
                        <h3>üìã OCR Results</h3>
                        <button class="clear-results" onclick="clearResults()">Clear</button>
                    </div>
                    <div id="resultsContainer" class="results-grid">
                        <div style="text-align: center; color: #6c757d; padding: 40px;">
                            <h4>No results yet</h4>
                            <p>Upload image and draw bboxes or use "Detect All" to see results</p>
                        </div>
                    </div>
                    
                    <div class="loading" id="loadingIndicator">
                        <div class="spinner"></div>
                        <p>Processing image...</p>
                    </div>
                </div>
            </div>

            <!-- Comparison Section -->
            <div class="comparison-section" id="comparisonSection" style="display: none;">
                <h3 class="comparison-header">‚öñÔ∏è Engine Comparison Results</h3>
                <div class="comparison-grid" id="comparisonContainer">
                    <!-- Comparison results will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentImage = null;
        let currentImageFile = null;
        let isDrawing = false;
        let startX, startY;
        let currentBbox = null;
        let detectedBboxes = [];
        let allResults = [];

        // DOM elements
        const imageInput = document.getElementById('imageInput');
        const previewImage = document.getElementById('previewImage');
        const imageContainer = document.getElementById('imageContainer');
        const bboxOverlay = document.getElementById('bboxOverlay');
        const placeholderText = document.getElementById('placeholderText');
        const fileInfo = document.getElementById('fileInfo');
        const resultsContainer = document.getElementById('resultsContainer');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const comparisonSection = document.getElementById('comparisonSection');
        const comparisonContainer = document.getElementById('comparisonContainer');

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            checkEngineStatus();
        });

        // Handle window resize to update bbox positions
        window.addEventListener('resize', function() {
            if (currentImage && allResults.length > 0) {
                // Redraw all bboxes with new positions
                redrawAllBboxes();
            }
        });

        function setupEventListeners() {
            // File input
            imageInput.addEventListener('change', handleImageUpload);

            // Engine selection
            document.querySelectorAll('.engine-option').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.engine-option').forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    option.querySelector('input[type=radio]').checked = true;
                });
            });

            // Action buttons
            document.getElementById('detectAllBtn').addEventListener('click', detectAllText);
            document.getElementById('clearAllBtn').addEventListener('click', clearAll);
            document.getElementById('compareBtn').addEventListener('click', compareEngines);

            // Mouse events for drawing bboxes
            imageContainer.addEventListener('mousedown', startDrawing);
            
            // Add global mouse events to handle drawing outside the container
            document.addEventListener('mousemove', function(event) {
                if (isDrawing) {
                    drawBbox(event);
                }
            });
            
            document.addEventListener('mouseup', function(event) {
                if (isDrawing) {
                    endDrawing(event);
                }
            });
            
            // Prevent context menu on right click
            imageContainer.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Prevent default drag behavior on the image
            previewImage.addEventListener('dragstart', (e) => e.preventDefault());
            
            // Handle image load event to update overlay
            previewImage.addEventListener('load', function() {
                setTimeout(() => {
                    if (allResults.length > 0) {
                        redrawAllBboxes();
                    }
                }, 100);
            });
            
            // Cleanup drawing state when mouse leaves window
            document.addEventListener('mouseleave', function() {
                if (isDrawing && currentBbox) {
                    currentBbox.remove();
                    currentBbox = null;
                    isDrawing = false;
                    document.body.style.userSelect = '';
                    document.body.style.webkitUserSelect = '';
                }
            });
        }

        async function checkEngineStatus() {
            try {
                const response = await fetch('/health');
                const data = await response.json();
                
                // Update engine status indicators
                updateEngineStatus('paddleocr', data.engines.paddleocr.available);
                updateEngineStatus('vietocr', data.engines.vietocr.available);
            } catch (error) {
                console.error('Error checking engine status:', error);
            }
        }

        function updateEngineStatus(engine, available) {
            const option = document.querySelector(`[data-engine="${engine}"]`);
            const indicator = option.querySelector('.status-indicator');
            
            if (available) {
                indicator.className = 'status-indicator status-ready';
                option.style.opacity = '1';
            } else {
                indicator.className = 'status-indicator status-error';
                option.style.opacity = '0.6';
                option.style.pointerEvents = 'none';
            }
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            currentImageFile = file;
            
            // Update file info
            fileInfo.textContent = `${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;

            // Create image preview
            const reader = new FileReader();
            reader.onload = function(e) {
                currentImage = e.target.result;
                previewImage.src = e.target.result;
                
                // Wait for image to load before showing
                previewImage.onload = function() {
                    previewImage.style.display = 'block';
                    placeholderText.style.display = 'none';
                    imageContainer.classList.add('has-image');
                    
                    console.log('Image loaded:', {
                        naturalWidth: previewImage.naturalWidth,
                        naturalHeight: previewImage.naturalHeight,
                        displayWidth: previewImage.clientWidth,
                        displayHeight: previewImage.clientHeight
                    });
                };
                
                // Clear previous results
                clearResults();
                clearBboxes();
            };
            reader.readAsDataURL(file);
        }

        function startDrawing(event) {
            if (!currentImage || !previewImage.complete) return;
            
            // Prevent default behavior and stop propagation
            event.preventDefault();
            event.stopPropagation();
            
            const imageRect = previewImage.getBoundingClientRect();
            
            // Check if click is on the image
            if (event.clientX < imageRect.left || event.clientX > imageRect.right ||
                event.clientY < imageRect.top || event.clientY > imageRect.bottom) {
                return;
            }

            isDrawing = true;
            startX = event.clientX - imageRect.left;
            startY = event.clientY - imageRect.top;
            
            console.log('Start drawing at:', { startX, startY, imageRect });

            // Create drawing bbox
            currentBbox = document.createElement('div');
            currentBbox.className = 'bbox-drawing';
            currentBbox.style.left = startX + 'px';
            currentBbox.style.top = startY + 'px';
            currentBbox.style.position = 'absolute';
            currentBbox.style.pointerEvents = 'none';
            bboxOverlay.appendChild(currentBbox);
            
            // Disable text selection while drawing
            document.body.style.userSelect = 'none';
            document.body.style.webkitUserSelect = 'none';
        }

        function drawBbox(event) {
            if (!isDrawing || !currentBbox) return;
            
            // Prevent default behavior and stop propagation
            event.preventDefault();
            event.stopPropagation();

            const imageRect = previewImage.getBoundingClientRect();
            const currentX = event.clientX - imageRect.left;
            const currentY = event.clientY - imageRect.top;

            const width = Math.abs(currentX - startX);
            const height = Math.abs(currentY - startY);
            const left = Math.min(currentX, startX);
            const top = Math.min(currentY, startY);

            currentBbox.style.left = left + 'px';
            currentBbox.style.top = top + 'px';
            currentBbox.style.width = width + 'px';
            currentBbox.style.height = height + 'px';
        }

        async function endDrawing(event) {
            if (!isDrawing || !currentBbox) return;
            
            // Prevent default behavior and stop propagation
            event.preventDefault();
            event.stopPropagation();
            
            isDrawing = false;
            
            // Re-enable text selection
            document.body.style.userSelect = '';
            document.body.style.webkitUserSelect = '';

            // Get final bbox coordinates relative to the image
            const imageRect = previewImage.getBoundingClientRect();
            const bboxRect = currentBbox.getBoundingClientRect();
            
            // Calculate bbox coordinates relative to the displayed image
            const relativeX1 = bboxRect.left - imageRect.left;
            const relativeY1 = bboxRect.top - imageRect.top;
            const relativeX2 = bboxRect.right - imageRect.left;
            const relativeY2 = bboxRect.bottom - imageRect.top;
            
            // Convert to actual image coordinates
            const scaleX = previewImage.naturalWidth / previewImage.clientWidth;
            const scaleY = previewImage.naturalHeight / previewImage.clientHeight;
            
            const x1 = Math.round(relativeX1 * scaleX);
            const y1 = Math.round(relativeY1 * scaleY);
            const x2 = Math.round(relativeX2 * scaleX);
            const y2 = Math.round(relativeY2 * scaleY);
            
            console.log('Bbox coordinates:', {
                relative: { x1: relativeX1, y1: relativeY1, x2: relativeX2, y2: relativeY2 },
                actual: { x1, y1, x2, y2 },
                scale: { scaleX, scaleY },
                imageSize: {
                    natural: { width: previewImage.naturalWidth, height: previewImage.naturalHeight },
                    display: { width: previewImage.clientWidth, height: previewImage.clientHeight }
                }
            });

            // Remove drawing bbox
            currentBbox.remove();
            currentBbox = null;

            // Only process if bbox has meaningful size
            if (Math.abs(x2 - x1) > 10 && Math.abs(y2 - y1) > 10) {
                await processBbox([x1, y1, x2, y2]);
            }
        }

        async function processBbox(bbox) {
            if (!currentImageFile) return;

            const selectedEngine = document.querySelector('input[name="engine"]:checked').value;
            showLoading(true);

            try {
                const formData = new FormData();
                formData.append('file', currentImageFile);
                formData.append('bbox', JSON.stringify(bbox));
                formData.append('bbox_format', 'xyxy');

                const response = await fetch(`/api/${selectedEngine}/single-bbox`, {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (result.success) {
                    addResultToDisplay(result, bbox);
                    drawBboxOnImage(bbox, result.text, result.confidence, selectedEngine);
                } else {
                    console.error('Error processing bbox:', result.error);
                    alert('Error processing bbox: ' + result.error);
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error processing bbox: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        async function detectAllText() {
            if (!currentImageFile) {
                alert('Please upload an image first');
                return;
            }

            showLoading(true);
            clearBboxes();
            clearResults();

            try {
                // Always use PaddleOCR for detection
                const formData = new FormData();
                formData.append('file', currentImageFile);

                const response = await fetch('/api/paddleocr/full-image', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (result.success && result.bboxes.length > 0) {
                    detectedBboxes = result.bboxes;
                    
                    // Display PaddleOCR results
                    for (let i = 0; i < result.texts.length; i++) {
                        const bbox = result.bboxes[i];
                        const text = result.texts[i];
                        const confidence = result.confidences[i];
                        
                        addResultToDisplay({
                            success: true,
                            engine: 'PaddleOCR',
                            text: text,
                            confidence: confidence
                        }, bbox, i);
                        
                        drawBboxOnImage(bbox, text, confidence, 'PaddleOCR', i);
                    }
                } else {
                    alert('No text detected in the image');
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error detecting text: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        async function compareEngines() {
            if (detectedBboxes.length === 0) {
                alert('Please run "Detect All Text" first to get bboxes for comparison');
                return;
            }

            showLoading(true);
            const comparisonResults = [];

            try {
                // Process each detected bbox with VietOCR
                for (let i = 0; i < detectedBboxes.length; i++) {
                    const bbox = detectedBboxes[i];
                    
                    // Convert polygon bbox to xyxy format
                    const xs = bbox.map(point => point[0]);
                    const ys = bbox.map(point => point[1]);
                    const xyxyBbox = [Math.min(...xs), Math.min(...ys), Math.max(...xs), Math.max(...ys)];

                    const formData = new FormData();
                    formData.append('file', currentImageFile);
                    formData.append('bbox', JSON.stringify(xyxyBbox));
                    formData.append('bbox_format', 'xyxy');

                    // Get VietOCR result
                    const vietResponse = await fetch('/api/vietocr/single-bbox', {
                        method: 'POST',
                        body: formData
                    });
                    const vietResult = await vietResponse.json();

                    // Find corresponding PaddleOCR result
                    const paddleResult = allResults.find(r => r.bboxIndex === i && r.engine === 'PaddleOCR');

                    comparisonResults.push({
                        bboxIndex: i,
                        paddleocr: paddleResult ? paddleResult.text : 'N/A',
                        vietocr: vietResult.success ? vietResult.text : 'Error',
                        bbox: bbox
                    });
                }

                displayComparison(comparisonResults);
                comparisonSection.style.display = 'block';

            } catch (error) {
                console.error('Error comparing engines:', error);
                alert('Error comparing engines: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        function addResultToDisplay(result, bbox, bboxIndex = null) {
            // Clear placeholder if this is the first result
            if (allResults.length === 0) {
                resultsContainer.innerHTML = '';
            }

            const resultItem = document.createElement('div');
            resultItem.className = 'result-item';
            
            // Store result data
            const resultData = {
                engine: result.engine,
                text: result.text,
                confidence: result.confidence,
                bbox: bbox,
                bboxIndex: bboxIndex
            };
            allResults.push(resultData);

            resultItem.innerHTML = `
                <div class="result-header">
                    <span class="result-engine">${result.engine}</span>
                    <span class="result-confidence">${(result.confidence * 100).toFixed(1)}%</span>
                </div>
                <div class="result-text">${result.text || 'No text detected'}</div>
            `;

            resultsContainer.appendChild(resultItem);
        }

        function drawBboxOnImage(bbox, text, confidence, engine, bboxIndex = null) {
            const bboxDiv = document.createElement('div');
            bboxDiv.className = 'bbox-detected';
            bboxDiv.dataset.bboxIndex = bboxIndex;

            let x1, y1, x2, y2;
            
            // Handle different bbox formats
            if (Array.isArray(bbox[0])) {
                // Polygon format
                const xs = bbox.map(point => point[0]);
                const ys = bbox.map(point => point[1]);
                x1 = Math.min(...xs);
                y1 = Math.min(...ys);
                x2 = Math.max(...xs);
                y2 = Math.max(...ys);
            } else {
                // XYXY format
                [x1, y1, x2, y2] = bbox;
            }

            // Calculate display coordinates
            const scaleX = previewImage.clientWidth / previewImage.naturalWidth;
            const scaleY = previewImage.clientHeight / previewImage.naturalHeight;

            const displayX = x1 * scaleX;
            const displayY = y1 * scaleY;
            const displayWidth = (x2 - x1) * scaleX;
            const displayHeight = (y2 - y1) * scaleY;
            
            console.log('Drawing bbox on image:', {
                original: { x1, y1, x2, y2 },
                display: { x: displayX, y: displayY, width: displayWidth, height: displayHeight },
                scale: { scaleX, scaleY }
            });

            bboxDiv.style.position = 'absolute';
            bboxDiv.style.left = displayX + 'px';
            bboxDiv.style.top = displayY + 'px';
            bboxDiv.style.width = displayWidth + 'px';
            bboxDiv.style.height = displayHeight + 'px';

            // Add label
            const label = document.createElement('div');
            label.className = 'bbox-label';
            label.textContent = `${engine}: ${text} (${(confidence * 100).toFixed(1)}%)`;
            bboxDiv.appendChild(label);

            bboxOverlay.appendChild(bboxDiv);
        }

        function displayComparison(results) {
            comparisonContainer.innerHTML = '';

            results.forEach((result, index) => {
                const comparisonItem = document.createElement('div');
                comparisonItem.className = 'comparison-item';
                
                comparisonItem.innerHTML = `
                    <h4>Region ${index + 1}</h4>
                    <div style="margin: 15px 0;">
                        <strong>üî• PaddleOCR:</strong>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; margin: 5px 0;">
                            ${result.paddleocr}
                        </div>
                    </div>
                    <div style="margin: 15px 0;">
                        <strong>üáªüá≥ VietOCR:</strong>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; margin: 5px 0;">
                            ${result.vietocr}
                        </div>
                    </div>
                    <div style="font-size: 0.9em; color: #6c757d;">
                        ${result.paddleocr === result.vietocr ? '‚úÖ Results match' : '‚ö†Ô∏è Results differ'}
                    </div>
                `;

                comparisonContainer.appendChild(comparisonItem);
            });
        }

        function clearBboxes() {
            bboxOverlay.innerHTML = '';
            detectedBboxes = [];
        }

        function clearResults() {
            allResults = [];
            resultsContainer.innerHTML = `
                <div style="text-align: center; color: #6c757d; padding: 40px;">
                    <h4>No results yet</h4>
                    <p>Upload image and draw bboxes or use "Detect All" to see results</p>
                </div>
            `;
        }

        function clearAll() {
            clearBboxes();
            clearResults();
            comparisonSection.style.display = 'none';
        }

        function showLoading(show) {
            loadingIndicator.style.display = show ? 'block' : 'none';
        }

        function redrawAllBboxes() {
            // Clear existing bbox overlays
            const existingBboxes = bboxOverlay.querySelectorAll('.bbox-detected');
            existingBboxes.forEach(bbox => bbox.remove());
            
            // Redraw all bboxes with updated positions
            allResults.forEach(result => {
                if (result.bbox) {
                    drawBboxOnImage(result.bbox, result.text, result.confidence, result.engine, result.bboxIndex);
                }
            });
        }
    </script>
</body>
</html>
