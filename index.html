<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PaddleOCR API Interface</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .upload-section {
            border: 2px dashed #ddd;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            border-radius: 10px;
            transition: border-color 0.3s;
        }
        .upload-section:hover {
            border-color: #007bff;
        }
        .upload-section.dragover {
            border-color: #007bff;
            background-color: #f8f9fa;
        }
        #imageInput {
            display: none;
        }
        .upload-btn {
            background-color: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
        }
        .upload-btn:hover {
            background-color: #0056b3;
        }
        .process-btn {
            background-color: #28a745;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
        }
        .process-btn:hover {
            background-color: #1e7e34;
        }
        .process-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .image-container {
            position: relative;
            display: inline-block;
            margin: 20px 0;
            cursor: crosshair;
        }
        #previewImage {
            max-width: 100%;
            max-height: 500px;
            border: 1px solid #ddd;
            border-radius: 5px;
            user-select: none;
        }
        .bbox-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: auto;
            width: 100%;
            height: 100%;
        }
        .bbox {
            position: absolute;
            border: 2px solid #ff0000;
            background-color: rgba(255, 0, 0, 0.1);
            cursor: move;
            pointer-events: auto;
        }
        .bbox-drawing {
            position: absolute;
            border: 2px dashed #00ff00;
            background-color: rgba(0, 255, 0, 0.1);
            pointer-events: none;
        }
        .bbox-detected {
            position: absolute;
            border: 2px solid #0066cc;
            background-color: rgba(0, 102, 204, 0.1);
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .bbox-detected:hover {
            background-color: rgba(0, 102, 204, 0.2);
            border-width: 3px;
        }
        .bbox-detected-label {
            position: absolute;
            top: -25px;
            left: 0;
            background-color: #0066cc;
            color: white;
            padding: 2px 8px;
            font-size: 12px;
            border-radius: 3px;
            white-space: nowrap;
            font-weight: bold;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .bbox-label {
            position: absolute;
            top: -25px;
            left: 0;
            background-color: #ff0000;
            color: white;
            padding: 2px 8px;
            font-size: 12px;
            border-radius: 3px;
            white-space: nowrap;
        }
        .results {
            margin-top: 30px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .result-item {
            margin: 10px 0;
            padding: 15px;
            background-color: white;
            border-radius: 5px;
            border-left: 4px solid #007bff;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .result-item:hover {
            background-color: #f8f9fa;
            transform: translateX(5px);
        }
        .confidence {
            color: #28a745;
            font-weight: bold;
        }
        .loading {
            text-align: center;
            color: #007bff;
            font-style: italic;
        }
        .error {
            color: #dc3545;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 5px;
        }
        .bbox-controls {
            margin: 20px 0;
            text-align: center;
        }
        .coord-input {
            margin: 5px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            width: 80px;
        }
        .api-info {
            background-color: #e7f3ff;
            border: 1px solid #b3d9ff;
            border-radius: 5px;
            padding: 15px;
            margin: 20px 0;
        }
        .api-info h3 {
            margin-top: 0;
            color: #0066cc;
        }
        .api-endpoint {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 8px;
            font-family: monospace;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç PaddleOCR API Interface</h1>
        
        <div class="api-info">
            <h3>üì° API Information</h3>
            <p><strong>Server URL:</strong> <span id="serverUrl">http://localhost:8000</span></p>
            <p><strong>Available Endpoints:</strong></p>
            <div class="api-endpoint">POST /process-full-image - Process entire image</div>
            <div class="api-endpoint">POST /process-bboxes - Process multiple bboxes</div>
            <div class="api-endpoint">POST /process-single-bbox - Process single bbox</div>
            <div class="api-endpoint">GET /health - Health check</div>
            
            <h4>üéØ Interactive Features:</h4>
            <ul style="margin: 10px 0; padding-left: 20px;">
                <li>üñ±Ô∏è <strong>Drag on image</strong> to create bboxes</li>
                <li>üîç <strong>Blue boxes</strong> show detected text regions with labels</li>
                <li>üëÜ <strong>Click on boxes</strong> or results to highlight corresponding items</li>
                <li>‚ùå <strong>Click on red boxes</strong> to remove manual bboxes</li>
            </ul>
        </div>
        
        <div class="upload-section" id="uploadSection">
            <p>üìÅ Drag and drop an image here or click to select</p>
            <input type="file" id="imageInput" accept="image/*">
            <button class="upload-btn" onclick="document.getElementById('imageInput').click()">
                Select Image
            </button>
        </div>
        
        <div id="imagePreview" style="display: none;">
            <div class="image-container">
                <img id="previewImage" alt="Preview">
                <div class="bbox-overlay" id="bboxOverlay"></div>
            </div>
            
            <div class="bbox-controls">
                <h3>üéØ Bbox Controls</h3>
                <p><strong>Drag on image to create bbox</strong> or enter coordinates manually:</p>
                <p>Manual Bbox (XYXY format):</p>
                <input type="number" id="x1" class="coord-input" placeholder="X1">
                <input type="number" id="y1" class="coord-input" placeholder="Y1">
                <input type="number" id="x2" class="coord-input" placeholder="X2">
                <input type="number" id="y2" class="coord-input" placeholder="Y2">
                <button class="upload-btn" onclick="addManualBbox()">Add Bbox</button>
                <button class="upload-btn" onclick="clearBboxes()">Clear All</button>
                <p><small>üìå Click on a bbox to remove it</small></p>
            </div>
            
            <div style="text-align: center;">
                <button class="process-btn" id="processFullBtn" onclick="processFullImage()">
                    üîç Process Full Image
                </button>
                <button class="process-btn" id="processBboxBtn" onclick="processBboxes()">
                    üéØ Process Selected Bboxes (<span id="bboxCount">0</span>)
                </button>
                <p><small>üí° If no bboxes are selected, full image will be processed automatically</small></p>
            </div>
        </div>
        
        <div id="results" class="results" style="display: none;">
            <h3>üìù Results</h3>
            <div id="resultsList"></div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE_URL = 'http://localhost:8000';
        
        let currentImage = null;
        let bboxes = [];
        let imageScale = 1;
        let isDrawing = false;
        let startX, startY;
        let currentDrawingBox = null;
        
        // File upload handling
        const uploadSection = document.getElementById('uploadSection');
        const imageInput = document.getElementById('imageInput');
        const imagePreview = document.getElementById('imagePreview');
        const previewImage = document.getElementById('previewImage');
        const bboxOverlay = document.getElementById('bboxOverlay');
        
        // Update server URL display
        document.getElementById('serverUrl').textContent = API_BASE_URL;
        
        // Drag and drop
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });
        
        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });
        
        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });
        
        imageInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });
        
        // Mouse events for drawing bboxes
        bboxOverlay.addEventListener('mousedown', startDrawing);
        bboxOverlay.addEventListener('mousemove', drawBbox);
        bboxOverlay.addEventListener('mouseup', endDrawing);
        bboxOverlay.addEventListener('mouseleave', endDrawing);
        
        function startDrawing(e) {
            if (!currentImage) return;
            
            isDrawing = true;
            const rect = bboxOverlay.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
            
            // Create drawing box
            currentDrawingBox = document.createElement('div');
            currentDrawingBox.className = 'bbox-drawing';
            currentDrawingBox.style.left = startX + 'px';
            currentDrawingBox.style.top = startY + 'px';
            currentDrawingBox.style.width = '0px';
            currentDrawingBox.style.height = '0px';
            bboxOverlay.appendChild(currentDrawingBox);
        }
        
        function drawBbox(e) {
            if (!isDrawing || !currentDrawingBox) return;
            
            const rect = bboxOverlay.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            const width = Math.abs(currentX - startX);
            const height = Math.abs(currentY - startY);
            const left = Math.min(currentX, startX);
            const top = Math.min(currentY, startY);
            
            currentDrawingBox.style.left = left + 'px';
            currentDrawingBox.style.top = top + 'px';
            currentDrawingBox.style.width = width + 'px';
            currentDrawingBox.style.height = height + 'px';
        }
        
        function endDrawing(e) {
            if (!isDrawing || !currentDrawingBox) return;
            
            isDrawing = false;
            
            const rect = bboxOverlay.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            // Calculate bbox coordinates in original image scale
            const x1 = Math.min(startX, currentX) / imageScale;
            const y1 = Math.min(startY, currentY) / imageScale;
            const x2 = Math.max(startX, currentX) / imageScale;
            const y2 = Math.max(startY, currentY) / imageScale;
            
            // Remove drawing box
            bboxOverlay.removeChild(currentDrawingBox);
            currentDrawingBox = null;
            
            // Add bbox if it's large enough
            if (Math.abs(x2 - x1) > 10 && Math.abs(y2 - y1) > 10) {
                const bbox = { 
                    x1: Math.round(x1), 
                    y1: Math.round(y1), 
                    x2: Math.round(x2), 
                    y2: Math.round(y2) 
                };
                bboxes.push(bbox);
                drawBboxes();
                updateProcessButton();
            }
        }
        
        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                currentImage = file;
                previewImage.src = e.target.result;
                previewImage.onload = () => {
                    calculateImageScale();
                    imagePreview.style.display = 'block';
                    clearResults();
                    clearBboxes();
                };
            };
            reader.readAsDataURL(file);
        }
        
        function calculateImageScale() {
            const naturalWidth = previewImage.naturalWidth;
            const naturalHeight = previewImage.naturalHeight;
            const displayWidth = previewImage.clientWidth;
            const displayHeight = previewImage.clientHeight;
            
            imageScale = Math.min(displayWidth / naturalWidth, displayHeight / naturalHeight);
            
            console.log('Image scale calculation:', {
                naturalWidth,
                naturalHeight,
                displayWidth,
                displayHeight,
                imageScale
            });
        }
        
        function addManualBbox() {
            const x1 = parseInt(document.getElementById('x1').value);
            const y1 = parseInt(document.getElementById('y1').value);
            const x2 = parseInt(document.getElementById('x2').value);
            const y2 = parseInt(document.getElementById('y2').value);
            
            if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) {
                alert('Please enter valid coordinates');
                return;
            }
            
            const bbox = { x1, y1, x2, y2 };
            bboxes.push(bbox);
            drawBboxes();
            updateProcessButton();
            
            // Clear inputs
            document.getElementById('x1').value = '';
            document.getElementById('y1').value = '';
            document.getElementById('x2').value = '';
            document.getElementById('y2').value = '';
        }
        
        function clearBboxes() {
            bboxes = [];
            drawBboxes();
            clearDetectedBboxes();
            updateProcessButton();
        }
        
        function clearDetectedBboxes() {
            // Remove all detected bboxes
            const detectedBboxes = bboxOverlay.querySelectorAll('.bbox-detected');
            detectedBboxes.forEach(bbox => bbox.remove());
        }
        
        function drawDetectedBboxes(detectedBboxes, texts, confidences) {
            // Clear previous detected bboxes
            clearDetectedBboxes();
            
            if (!detectedBboxes || detectedBboxes.length === 0) return;
            
            console.log('Drawing detected bboxes:', {
                detectedBboxes,
                texts,
                confidences,
                imageScale
            });
            
            detectedBboxes.forEach((bbox, index) => {
                const text = texts[index] || '';
                const confidence = confidences[index] || 0;
                
                console.log(`Processing bbox ${index}:`, bbox);
                
                // Create bbox element
                const bboxDiv = document.createElement('div');
                bboxDiv.className = 'bbox-detected';
                
                // Calculate bbox coordinates based on format
                let x1, y1, x2, y2;
                
                if (Array.isArray(bbox) && bbox.length === 4 && Array.isArray(bbox[0])) {
                    // Polygon format [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]
                    console.log('Polygon format detected');
                    const xs = bbox.map(point => point[0]);
                    const ys = bbox.map(point => point[1]);
                    x1 = Math.min(...xs);
                    y1 = Math.min(...ys);
                    x2 = Math.max(...xs);
                    y2 = Math.max(...ys);
                } else if (Array.isArray(bbox) && bbox.length === 4 && !Array.isArray(bbox[0])) {
                    // XYXY format [x1, y1, x2, y2]
                    console.log('XYXY format detected');
                    [x1, y1, x2, y2] = bbox;
                } else {
                    console.warn('Unknown bbox format:', bbox);
                    return;
                }
                
                console.log(`Bbox ${index} coordinates:`, { x1, y1, x2, y2 });
                
                // Get image container offset
                const imageRect = previewImage.getBoundingClientRect();
                const overlayRect = bboxOverlay.getBoundingClientRect();
                
                // Calculate actual display scale (image might be scaled differently than calculated)
                const actualImageWidth = previewImage.clientWidth;
                const actualImageHeight = previewImage.clientHeight;
                const scaleX = actualImageWidth / previewImage.naturalWidth;
                const scaleY = actualImageHeight / previewImage.naturalHeight;
                
                console.log(`Bbox ${index} scales:`, { scaleX, scaleY, actualImageWidth, actualImageHeight });
                
                // Apply scaling to coordinates
                const scaledX1 = x1 * scaleX;
                const scaledY1 = y1 * scaleY;
                const scaledX2 = x2 * scaleX;
                const scaledY2 = y2 * scaleY;
                
                const width = scaledX2 - scaledX1;
                const height = scaledY2 - scaledY1;
                
                console.log(`Bbox ${index} final position:`, { 
                    left: scaledX1, 
                    top: scaledY1, 
                    width, 
                    height 
                });
                
                // Set position and size
                bboxDiv.style.left = scaledX1 + 'px';
                bboxDiv.style.top = scaledY1 + 'px';
                bboxDiv.style.width = width + 'px';
                bboxDiv.style.height = height + 'px';
                
                // Create label
                const label = document.createElement('div');
                label.className = 'bbox-detected-label';
                const confValue = Array.isArray(confidence) ? confidence[0] : confidence;
                label.textContent = `${text} (${(confValue * 100).toFixed(1)}%)`;
                label.title = text; // Show full text on hover
                bboxDiv.appendChild(label);
                
                // Add click event to highlight result
                bboxDiv.addEventListener('click', () => {
                    highlightResult(index);
                });
                
                bboxOverlay.appendChild(bboxDiv);
            });
        }
        
        function highlightResult(index) {
            // Scroll to and highlight the corresponding result item
            const resultItems = document.querySelectorAll('.result-item');
            if (resultItems[index]) {
                resultItems[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
                resultItems[index].style.backgroundColor = '#e7f3ff';
                resultItems[index].style.transform = 'scale(1.02)';
                
                // Reset highlight after 2 seconds
                setTimeout(() => {
                    resultItems[index].style.backgroundColor = 'white';
                    resultItems[index].style.transform = 'scale(1)';
                }, 2000);
            }
        }
        
        function drawBboxes() {
            const overlay = document.getElementById('bboxOverlay');
            overlay.innerHTML = '';
            
            bboxes.forEach((bbox, index) => {
                const bboxDiv = document.createElement('div');
                bboxDiv.className = 'bbox';
                bboxDiv.style.left = (bbox.x1 * imageScale) + 'px';
                bboxDiv.style.top = (bbox.y1 * imageScale) + 'px';
                bboxDiv.style.width = ((bbox.x2 - bbox.x1) * imageScale) + 'px';
                bboxDiv.style.height = ((bbox.y2 - bbox.y1) * imageScale) + 'px';
                
                const label = document.createElement('div');
                label.className = 'bbox-label';
                label.textContent = `Bbox ${index + 1}`;
                bboxDiv.appendChild(label);
                
                bboxDiv.addEventListener('click', () => {
                    if (confirm(`Remove Bbox ${index + 1}?`)) {
                        bboxes.splice(index, 1);
                        drawBboxes();
                        updateProcessButton();
                    }
                });
                
                overlay.appendChild(bboxDiv);
            });
        }
        
        function updateProcessButton() {
            const processBboxBtn = document.getElementById('processBboxBtn');
            const bboxCount = document.getElementById('bboxCount');
            
            bboxCount.textContent = bboxes.length;
            
            if (bboxes.length === 0) {
                processBboxBtn.innerHTML = 'üéØ Process Selected Bboxes (0) - Will process full image';
            } else {
                processBboxBtn.innerHTML = `üéØ Process Selected Bboxes (${bboxes.length})`;
            }
        }
        
        function clearResults() {
            document.getElementById('results').style.display = 'none';
            document.getElementById('resultsList').innerHTML = '';
            clearDetectedBboxes();
        }
        
        async function processFullImage() {
            if (!currentImage) {
                alert('Please select an image first');
                return;
            }
            
            showLoading('Processing full image...');
            
            const formData = new FormData();
            formData.append('file', currentImage);
            
            try {
                const response = await fetch(`${API_BASE_URL}/process-full-image`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    displayResults(result, 'Full Image OCR Results');
                } else {
                    showError(result.detail || 'Error processing image');
                }
            } catch (error) {
                showError('Network error: ' + error.message);
            }
        }
        
        async function processBboxes() {
            if (!currentImage) {
                alert('Please select an image first');
                return;
            }
            
            // If no bboxes, process full image instead
            if (bboxes.length === 0) {
                showLoading('No bboxes selected. Processing full image...');
                await processFullImage();
                return;
            }
            
            showLoading(`Processing ${bboxes.length} bboxes...`);
            
            const formData = new FormData();
            formData.append('file', currentImage);
            formData.append('bboxes', JSON.stringify(bboxes));
            formData.append('bbox_format', 'xyxy');
            
            try {
                const response = await fetch(`${API_BASE_URL}/process-bboxes`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    displayBboxResults(result, 'Bbox OCR Results');
                } else {
                    showError(result.detail || 'Error processing bboxes');
                }
            } catch (error) {
                showError('Network error: ' + error.message);
            }
        }
        
        function showLoading(message) {
            const results = document.getElementById('results');
            const resultsList = document.getElementById('resultsList');
            
            results.style.display = 'block';
            resultsList.innerHTML = `<div class="loading">${message}</div>`;
        }
        
        function showError(message) {
            const results = document.getElementById('results');
            const resultsList = document.getElementById('resultsList');
            
            results.style.display = 'block';
            resultsList.innerHTML = `<div class="error">‚ùå ${message}</div>`;
        }
        
        function displayResults(result, title) {
            const results = document.getElementById('results');
            const resultsList = document.getElementById('resultsList');
            
            let html = `<h4>${title}</h4>`;
            html += `<p><strong>Found ${result.count} text regions</strong></p>`;
            
            if (result.texts && result.texts.length > 0) {
                // Draw detected bboxes on image
                drawDetectedBboxes(result.bboxes, result.texts, result.confidences);
                
                result.texts.forEach((text, index) => {
                    const confidence = result.confidences[index];
                    const confValue = Array.isArray(confidence) ? confidence[0] : confidence;
                    
                    html += `
                        <div class="result-item" data-index="${index}">
                            <strong>Text ${index + 1}:</strong> "${text}"<br>
                            <span class="confidence">Confidence: ${(confValue * 100).toFixed(1)}%</span>
                            <br><small>üìç Click on bbox on image to highlight this result</small>
                        </div>
                    `;
                });
            } else {
                html += '<p>No text found in the image.</p>';
            }
            
            results.style.display = 'block';
            resultsList.innerHTML = html;
            
            // Add click handlers to result items to highlight corresponding bbox
            const resultItems = document.querySelectorAll('.result-item');
            resultItems.forEach((item, index) => {
                item.addEventListener('click', () => {
                    highlightBbox(index);
                });
            });
        }
        
        function highlightBbox(index) {
            // Highlight the corresponding bbox
            const detectedBboxes = document.querySelectorAll('.bbox-detected');
            if (detectedBboxes[index]) {
                // Remove previous highlights
                detectedBboxes.forEach(bbox => {
                    bbox.style.borderColor = '#0066cc';
                    bbox.style.borderWidth = '2px';
                });
                
                // Highlight selected bbox
                const targetBbox = detectedBboxes[index];
                targetBbox.style.borderColor = '#ff6600';
                targetBbox.style.borderWidth = '4px';
                
                // Scroll bbox into view
                targetBbox.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Reset highlight after 3 seconds
                setTimeout(() => {
                    targetBbox.style.borderColor = '#0066cc';
                    targetBbox.style.borderWidth = '2px';
                }, 3000);
            }
        }
        
        function displayBboxResults(results, title) {
            const resultsDiv = document.getElementById('results');
            const resultsList = document.getElementById('resultsList');
            
            let html = `<h4>${title}</h4>`;
            html += `<p><strong>Processed ${results.length} bboxes</strong></p>`;
            
            if (results && results.length > 0) {
                // Extract data for drawing
                const detectedBboxes = results.map(r => r.bbox);
                const texts = results.map(r => r.text || 'No text found');
                const confidences = results.map(r => r.confidence || 0);
                
                // Draw detected bboxes on image (these are the user-selected bboxes with results)
                drawDetectedBboxes(detectedBboxes, texts, confidences);
                
                results.forEach((result, index) => {
                    const confidence = result.confidence || 0;
                    
                    html += `
                        <div class="result-item" data-index="${index}">
                            <strong>Bbox ${index + 1}:</strong> "${result.text || 'No text found'}"<br>
                            <span class="confidence">Confidence: ${(confidence * 100).toFixed(1)}%</span>
                            <br><small>üìç Click on bbox on image to highlight this result</small>
                        </div>
                    `;
                });
            } else {
                html += '<p>No text found in the bboxes.</p>';
            }
            
            resultsDiv.style.display = 'block';
            resultsList.innerHTML = html;
            
            // Add click handlers to result items
            const resultItems = document.querySelectorAll('.result-item');
            resultItems.forEach((item, index) => {
                item.addEventListener('click', () => {
                    highlightBbox(index);
                });
            });
        }
        
        // Health check on page load
        async function checkHealth() {
            try {
                const response = await fetch(`${API_BASE_URL}/health`);
                const result = await response.json();
                
                if (response.ok && result.status === 'healthy') {
                    console.log('‚úÖ API server is healthy');
                } else {
                    console.warn('‚ö†Ô∏è API server may have issues');
                }
            } catch (error) {
                console.error('‚ùå Cannot connect to API server:', error.message);
                showError('Cannot connect to API server. Please make sure the server is running on ' + API_BASE_URL);
            }
        }
        
        // Check health on page load
        window.addEventListener('load', checkHealth);
    </script>
</body>
</html>
