# üîç ORB Image Alignment API

![Example1](img_doc/Example1.png)

## üìã T·ªïng quan

ORB Image Alignment API l√† m·ªôt d·ªãch v·ª• web s·ª≠ d·ª•ng thu·∫≠t to√°n ORB (Oriented FAST and Rotated BRIEF) ƒë·ªÉ th·ª±c hi·ªán alignment ·∫£nh. API n√†y c√≥ th·ªÉ cƒÉn ch·ªânh v√† kh·ªõp c√°c ƒë·∫∑c tr∆∞ng gi·ªØa hai ·∫£nh, h·ªØu √≠ch trong c√°c ·ª©ng d·ª•ng computer vision nh∆∞ nh·∫≠n d·∫°ng v·∫≠t th·ªÉ, theo d√µi chuy·ªÉn ƒë·ªông, v√† x·ª≠ l√Ω ·∫£nh.

## üöÄ T√≠nh nƒÉng ch√≠nh

- ‚ú® **ORB Feature Detection**: Ph√°t hi·ªán v√† m√¥ t·∫£ ƒë·∫∑c tr∆∞ng ORB
- üîÑ **Image Alignment**: CƒÉn ch·ªânh ·∫£nh target theo ·∫£nh template
- üìè **Size Normalization**: T·ª± ƒë·ªông chu·∫©n h√≥a k√≠ch th∆∞·ªõc ·∫£nh
- üéØ **Robust Homography**: T√≠nh to√°n ma tr·∫≠n homography v·ªõi RANSAC
- üìä **Quality Assessment**: ƒê√°nh gi√° ch·∫•t l∆∞·ª£ng alignment
- üñºÔ∏è **Visualization**: T·∫°o ·∫£nh minh h·ªça c√°c feature points v√† matches
- üåê **Web Interface**: Giao di·ªán web ƒë·∫πp ƒë·ªÉ test API

## üì¶ C√†i ƒë·∫∑t

### Y√™u c·∫ßu h·ªá th·ªëng
- Python 3.8+
- OpenCV 4.x
- FastAPI
- SQLite (t√πy ch·ªçn)

### C√†i ƒë·∫∑t dependencies

```bash
pip install -r requitement.txt
```

### Ch·∫°y ·ª©ng d·ª•ng

```bash
python main.py
```

API s·∫Ω ch·∫°y t·∫°i: `http://localhost:5000`

## üê≥ Docker

### Build v√† ch·∫°y v·ªõi Docker

```bash
# Build image
docker build -t orb-image-alignment-api .

# Ch·∫°y container
docker run -d -p 5000:5000 --name orb-api orb-image-alignment-api
```

### S·ª≠ d·ª•ng Docker Compose

```bash
docker-compose up -d
```

## üìö H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng ORBImageAligner

### Kh·ªüi t·∫°o

```python
from service.orb.ORBImageAligner import ORBImageAligner

# Kh·ªüi t·∫°o v·ªõi tham s·ªë m·∫∑c ƒë·ªãnh
aligner = ORBImageAligner()

# Ho·∫∑c t√πy ch·ªânh tham s·ªë
aligner = ORBImageAligner(
    target_dimension=800,  # K√≠ch th∆∞·ªõc chu·∫©n ƒë·ªÉ normalize
    orb_features=2000     # S·ªë l∆∞·ª£ng ORB features t·ªëi ƒëa
)
```

### C√°c tham s·ªë kh·ªüi t·∫°o

| Tham s·ªë | Ki·ªÉu d·ªØ li·ªáu | M·∫∑c ƒë·ªãnh | M√¥ t·∫£ |
|---------|--------------|----------|-------|
| `target_dimension` | int | 800 | K√≠ch th∆∞·ªõc chu·∫©n ƒë·ªÉ normalize ·∫£nh |
| `orb_features` | int | 2000 | S·ªë l∆∞·ª£ng ORB features t·ªëi ƒëa |

### S·ª≠ d·ª•ng c∆° b·∫£n

```python
import cv2
from service.orb.ORBImageAligner import ORBImageAligner

# Kh·ªüi t·∫°o aligner
aligner = ORBImageAligner(target_dimension=800, orb_features=2000)

# ƒê·ªçc ·∫£nh
base_img = cv2.imread('path/to/template.jpg')
target_img = cv2.imread('path/to/target.jpg')

# Th·ª±c hi·ªán alignment
result = aligner.align(base_img, target_img)

# Ki·ªÉm tra k·∫øt qu·∫£
if result["success"]:
    print("‚úÖ Alignment th√†nh c√¥ng!")
    
    # L·∫•y ·∫£nh ƒë√£ aligned
    aligned_image = result["aligned_image"]
    
    # L∆∞u k·∫øt qu·∫£
    cv2.imwrite('aligned_result.jpg', aligned_image)
    
    # In th·ªëng k√™
    aligner.print_result_summary(result)
else:
    print(f"‚ùå Alignment th·∫•t b·∫°i: {result['error']}")
```

### K·∫øt qu·∫£ tr·∫£ v·ªÅ

H√†m `align()` tr·∫£ v·ªÅ m·ªôt dictionary ch·ª©a:

```python
{
    "success": bool,                    # Tr·∫°ng th√°i th√†nh c√¥ng
    "aligned_image": numpy.ndarray,     # ·∫¢nh ƒë√£ aligned
    "visualization_image": numpy.ndarray, # ·∫¢nh minh h·ªça features
    "comparison_image": numpy.ndarray,   # ·∫¢nh so s√°nh before/after
    "base_image": numpy.ndarray,        # ·∫¢nh base g·ªëc
    "target_image": numpy.ndarray,      # ·∫¢nh target g·ªëc
    "original_sizes": {                 # K√≠ch th∆∞·ªõc ·∫£nh g·ªëc
        "base": tuple,
        "target": tuple
    },
    "normalized_sizes": {               # K√≠ch th∆∞·ªõc sau normalize
        "base": tuple,
        "target": tuple
    },
    "features": {                       # S·ªë l∆∞·ª£ng features
        "base": int,
        "target": int
    },
    "good_matches": int,                # S·ªë l∆∞·ª£ng good matches
    "inliers": int,                     # S·ªë l∆∞·ª£ng inliers
    "inlier_ratio": float,              # T·ª∑ l·ªá inliers
    "quality_score": float,             # ƒêi·ªÉm ch·∫•t l∆∞·ª£ng (0-1)
    "homography_matrix": numpy.ndarray, # Ma tr·∫≠n homography
    "scales": {                         # T·ª∑ l·ªá scaling
        "base_scale": float,
        "target_scale": float
    }
}
```

### V√≠ d·ª• n√¢ng cao

```python
import cv2
import numpy as np
from service.orb.ORBImageAligner import ORBImageAligner

def process_image_alignment(template_path, target_path):
    """
    V√≠ d·ª• x·ª≠ l√Ω alignment v·ªõi error handling v√† optimization
    """
    
    # Kh·ªüi t·∫°o aligner v·ªõi tham s·ªë t·ªëi ∆∞u
    aligner = ORBImageAligner(
        target_dimension=1000,  # ƒê·ªô ph√¢n gi·∫£i cao h∆°n
        orb_features=5000      # Nhi·ªÅu features h∆°n
    )
    
    try:
        # ƒê·ªçc ·∫£nh v·ªõi error handling
        base_img = cv2.imread(template_path)
        target_img = cv2.imread(target_path)
        
        if base_img is None or target_img is None:
            raise ValueError("Kh√¥ng th·ªÉ ƒë·ªçc ·∫£nh")
        
        print(f"üìñ ƒê·ªçc ·∫£nh th√†nh c√¥ng:")
        print(f"  Template: {base_img.shape}")
        print(f"  Target: {target_img.shape}")
        
        # Th·ª±c hi·ªán alignment
        print("üîç B·∫Øt ƒë·∫ßu alignment...")
        result = aligner.align(base_img, target_img)
        
        if result["success"]:
            # L∆∞u c√°c k·∫øt qu·∫£
            cv2.imwrite('output_aligned.jpg', result["aligned_image"])
            cv2.imwrite('output_visualization.jpg', result["visualization_image"])
            cv2.imwrite('output_comparison.jpg', result["comparison_image"])
            
            # In th√¥ng tin chi ti·∫øt
            aligner.print_result_summary(result)
            
            # Ph√¢n t√≠ch ch·∫•t l∆∞·ª£ng
            quality = result["quality_score"]
            if quality > 0.8:
                print("üåü Alignment ch·∫•t l∆∞·ª£ng r·∫•t cao!")
            elif quality > 0.6:
                print("‚úÖ Alignment ch·∫•t l∆∞·ª£ng t·ªët")
            elif quality > 0.4:
                print("‚ö†Ô∏è Alignment ch·∫•t l∆∞·ª£ng trung b√¨nh")
            else:
                print("‚ùå Alignment ch·∫•t l∆∞·ª£ng th·∫•p")
            
            return result
            
        else:
            print(f"‚ùå Alignment th·∫•t b·∫°i: {result['error']}")
            return None
            
    except Exception as e:
        print(f"üí• L·ªói: {str(e)}")
        return None

# S·ª≠ d·ª•ng
if __name__ == "__main__":
    result = process_image_alignment(
        template_path="template.jpg",
        target_path="target.jpg"
    )
```

### T·ªëi ∆∞u h√≥a tham s·ªë

#### Cho ·∫£nh c√≥ ƒë·ªô ph√¢n gi·∫£i cao
```python
aligner = ORBImageAligner(
    target_dimension=1200,  # TƒÉng resolution
    orb_features=5000      # Nhi·ªÅu features h∆°n
)
```

#### Cho ·∫£nh c√≥ ƒë·ªô ph√¢n gi·∫£i th·∫•p
```python
aligner = ORBImageAligner(
    target_dimension=600,   # Gi·∫£m resolution
    orb_features=1000      # √çt features h∆°n
)
```

#### Cho ·∫£nh c√≥ nhi·ªÅu chi ti·∫øt
```python
aligner = ORBImageAligner(
    target_dimension=1000,
    orb_features=3000      # TƒÉng features ƒë·ªÉ b·∫Øt nhi·ªÅu chi ti·∫øt
)
```

### X·ª≠ l√Ω l·ªói th∆∞·ªùng g·∫∑p

#### 1. Kh√¥ng ƒë·ªß features
```python
result = aligner.align(base_img, target_img)
if not result["success"] and "features" in result["error"]:
    # Th·ª≠ gi·∫£m threshold ho·∫∑c tƒÉng s·ªë features
    aligner = ORBImageAligner(orb_features=3000)
    result = aligner.align(base_img, target_img)
```

#### 2. ·∫¢nh qu√° kh√°c bi·ªát
```python
if not result["success"] and "homography" in result["error"]:
    print("·∫¢nh c√≥ th·ªÉ qu√° kh√°c bi·ªát v·ªÅ g√≥c nh√¨n ho·∫∑c n·ªôi dung")
    # Th·ª≠ preprocessing ·∫£nh tr∆∞·ªõc
```

#### 3. Ch·∫•t l∆∞·ª£ng th·∫•p
```python
if result["success"] and result["quality_score"] < 0.3:
    print("C·∫£nh b√°o: K·∫øt qu·∫£ alignment c√≥ ch·∫•t l∆∞·ª£ng th·∫•p")
    print(f"Inlier ratio: {result['inlier_ratio']:.2%}")
    print(f"Good matches: {result['good_matches']}")
```

## üîß API Endpoints

### POST `/api/orb`
Th·ª±c hi·ªán ORB alignment gi·ªØa hai ·∫£nh

**Request:**
- `image_template`: File ·∫£nh template
- `image_target`: File ·∫£nh target

**Response:**
```json
{
    "success": true,
    "aligned_image_base64": "base64_string",
    "visualization_image_base64": "base64_string",
    "comparison_image_base64": "base64_string",
    "quality_score": 0.85,
    "inlier_ratio": 0.75,
    "features": {"base": 1500, "target": 1200},
    "good_matches": 300,
    "inliers": 225
}
```

### GET `/api/status`
Ki·ªÉm tra tr·∫°ng th√°i API

## üé® Web Interface

Truy c·∫≠p `http://localhost:5000` ƒë·ªÉ s·ª≠ d·ª•ng giao di·ªán web v·ªõi c√°c t√≠nh nƒÉng:

- üì§ Upload ·∫£nh template v√† target
- üñºÔ∏è Preview ·∫£nh tr∆∞·ªõc khi x·ª≠ l√Ω
- üìä Hi·ªÉn th·ªã k·∫øt qu·∫£ alignment v·ªõi th·ªëng k√™ chi ti·∫øt
- üí´ Giao di·ªán ƒë·∫πp, responsive tr√™n m·ªçi thi·∫øt b·ªã

## ‚ö° Performance Tips

1. **T·ªëi ∆∞u k√≠ch th∆∞·ªõc ·∫£nh**: S·ª≠ d·ª•ng `target_dimension` ph√π h·ª£p v·ªõi ·ª©ng d·ª•ng
2. **C√¢n b·∫±ng features**: Nhi·ªÅu features = ch√≠nh x√°c h∆°n nh∆∞ng ch·∫≠m h∆°n
3. **Preprocessing**: Enhance contrast v√† gi·∫£m noise tr∆∞·ªõc khi alignment
4. **Memory management**: X·ª≠ l√Ω ·∫£nh l·ªõn theo batch ƒë·ªÉ tr√°nh out of memory

## üêõ Troubleshooting

### L·ªói import OpenCV
```bash
pip install opencv-python-headless
```

### L·ªói memory v·ªõi ·∫£nh l·ªõn
Gi·∫£m `target_dimension` ho·∫∑c resize ·∫£nh tr∆∞·ªõc khi x·ª≠ l√Ω

### Alignment kh√¥ng ch√≠nh x√°c
- Ki·ªÉm tra ch·∫•t l∆∞·ª£ng ·∫£nh input
- TƒÉng s·ªë l∆∞·ª£ng ORB features
- ƒê·∫£m b·∫£o ·∫£nh c√≥ ƒë·ªß texture v√† chi ti·∫øt

## üìÑ License


## ü§ù Contributing

M·ªçi ƒë√≥ng g√≥p ƒë·ªÅu ƒë∆∞·ª£c ch√†o ƒë√≥n! Vui l√≤ng t·∫°o issue ho·∫∑c pull request.

## üìû Support

N·∫øu g·∫∑p v·∫•n ƒë·ªÅ, vui l√≤ng t·∫°o issue tr√™n GitHub repository.